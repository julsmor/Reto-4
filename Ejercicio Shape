**EJERCICIO**
Create a superclass called Shape(), which is the base of the classes Reactangle() and Square(), define the methods compute_area and compute_perimeter in Shape() and then using polymorphism redefine the methods properly in Rectangle and in Square.

Using the classes Point() and Line() define a new super-class Shape() with the following structure:

**Descripción del ejercicio:**
En este código se implementa herencia y polimorfismo. Primero, se definen las clases Point y Line, que modelan puntos y líneas en el plano, sirviendo como base geométrica. Luego, se crea la clase Shape, una superclase abstracta que define la estructura y los métodos comunes (como calcular área y perímetro) que deben ser implementados por las subclases. A partir de esta, se heredan Rectangle y Square: el Rectangle construye su geometría a partir de un vértice superior izquierdo, un ancho y una altura, calculando sus vértices, aristas y ángulos internos; mientras que Square hereda del rectángulo y asegura que todos los lados sean iguales. Finalmente, en la sección if __name__ == "__main__", se crean instancias de estas figuras, se muestran sus propiedades (área, perímetro y vértices) y se demuestra el polimorfismo, recorriendo una lista de figuras distintas pero tratadas de forma uniforme mediante sus métodos comunes.
```python
import math

class Point:

    def __init__(self, x: float = 0.0, y: float = 0.0):
        self.__x = x
        self.__y = y

    # --- Getters y Setters (encapsulamiento) ---
    def get_x(self) -> float:
        return self.__x

    def set_x(self, x: float):
        self.__x = x

    def get_y(self) -> float:
        return self.__y

    def set_y(self, y: float):
        self.__y = y

    # --- Método para calcular distancia ---
    def compute_distance(self, other_point: "Point") -> float:
        dx = self.__x - other_point.get_x()
        dy = self.__y - other_point.get_y()
        return math.sqrt(dx**2 + dy**2)

    def __repr__(self):
        return f"Point({self.__x}, {self.__y})"

class Line:

    def __init__(self, start_point: Point, end_point: Point):
        self.__start_point = start_point
        self.__end_point = end_point
        self.__length = self.compute_length()

    # --- Getters y Setters ---
    def get_start_point(self) -> Point:
        return self.__start_point

    def set_start_point(self, point: Point):
        self.__start_point = point
        self.__length = self.compute_length()

    def get_end_point(self) -> Point:
        return self.__end_point

    def set_end_point(self, point: Point):
        self.__end_point = point
        self.__length = self.compute_length()

    def get_length(self) -> float:
        return self.__length

    # --- Método ---
    def compute_length(self) -> float:
        return self.__start_point.compute_distance(self.__end_point)

    def __repr__(self):
        return f"Line({self.__start_point}, {self.__end_point}) - Length: {self.__length:.2f}"

class Shape:

    def __init__(self, vertices: list[Point]):
        self._vertices = vertices
        self._edges = self._create_edges()
        self._is_regular = False

    # --- Métodos protegidos ---
    def _create_edges(self) -> list[Line]:
        edges = []
        n = len(self._vertices)
        for i in range(n):
            start = self._vertices[i]
            end = self._vertices[(i + 1) % n]  # conecta el último con el primero
            edges.append(Line(start, end))
        return edges

    # --- Métodos abstractos (a redefinir) ---
    def compute_area(self) -> float:
        raise NotImplementedError("Este método debe redefinirse en las subclases.")

    def compute_perimeter(self) -> float:
        raise NotImplementedError("Este método debe redefinirse en las subclases.")

    # --- Getters y Setters ---
    def get_vertices(self) -> list[Point]:
        return self._vertices

    def set_vertices(self, vertices: list[Point]):
        self._vertices = vertices
        self._edges = self._create_edges()

    def get_edges(self) -> list[Line]:
        return self._edges

    def __repr__(self):
        return f"{self.__class__.__name__} con {len(self._vertices)} vértices"

class Rectangle(Shape):

    def __init__(self, bottom_left: Point, width: float, height: float):
        vertices = [
            bottom_left,
            Point(bottom_left.get_x() + width, bottom_left.get_y()),
            Point(bottom_left.get_x() + width, bottom_left.get_y() + height),
            Point(bottom_left.get_x(), bottom_left.get_y() + height)
        ]
        super().__init__(vertices)
        self._width = width
        self._height = height

    def compute_area(self) -> float:
        return self._width * self._height

    def compute_perimeter(self) -> float:
        return 2 * (self._width + self._height)

class Square(Rectangle):

    def __init__(self, bottom_left: Point, side: float):
        super().__init__(bottom_left, side, side)
        self._is_regular = True  # todos los lados iguales

    # Polimorfismo
    def compute_area(self) -> float:
        return self._width ** 2

    def compute_perimeter(self) -> float:
        return 4 * self._width

if __name__ == "__main__":
    p = Point(0, 0)
    rect = Rectangle(p, 4, 2)
    sq = Square(p, 3)

    print(rect)
    print(f"Área del rectángulo: {rect.compute_area()}")
    print(f"Perímetro del rectángulo: {rect.compute_perimeter()}")

    print(sq)
    print(f"Área del cuadrado: {sq.compute_area()}")
    print(f"Perímetro del cuadrado: {sq.compute_perimeter()}")
```
